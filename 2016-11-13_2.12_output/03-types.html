<!DOCTYPE html>
<html>
<head>
  <meta http-equiv='Content-Type' content='text/html; charset=utf-8' />

  <link rel="icon" type="image/png" href="public/favicon.ico">
  <link rel="shortcut icon" type="image/png" href="public/favicon.ico">

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      skipTags: ['script', 'noscript', 'style', 'textarea'],
      processEscapes: true
    }
  });
  </script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script src="http://code.jquery.com/jquery-2.1.3.min.js"></script>
  <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.2/styles/default.min.css">
  <!-- need to use include to see value of page.chapter variable -->
  <style type="text/css">
    h1 {
  /* must reset here */
  counter-reset: chapter 3;
}
h1:before {
  /* and must reset again here */
  counter-reset: chapter 3;
  content: "Chapter " counter(chapter);
  display: block;
}

h2 {
  /* must increment here */
  counter-increment: section;
  counter-reset: subsection;
}
h2:before {
  /* and must reset again here */
  counter-reset: chapter 3;

  content: counter(chapter) "." counter(section) ;
  display: inline;
  margin-right: 1em;
}
h2:after {
  /* can only have one counter-reset per tag, so can't do it in h2/h2:before... */
  counter-reset: example;
}

h3 {
  /* must increment here */
  counter-increment: subsection;
}
h3:before {
  /* and must reset again here */
  counter-reset: chapter 3;

  content: counter(chapter) "." counter(section) "." counter(subsection);
  display: inline;
  margin-right: 1em;
}
h3[id*='example'] {
  /* must increment here */
  counter-increment: example;
  display: inline;
}
h3[id*='example']:before {
  /* and must reset again here */
  counter-reset: chapter 3;

  content: "Example " counter(chapter) "." counter(section) "." counter(example);
  display: inline;
  margin-right: 1em;
}

.no-numbering, .no-numbering:before, .no-numbering:after {
  content: normal;
  counter-reset: none;
  counter-increment: none;
}

  </style>
  <link rel="stylesheet" type="text/css" href="public/stylesheets/screen.css">
  <link rel="stylesheet" type="text/css" media="(max-width: 1400px), (orientation: portrait)" href="public/stylesheets/screen-small.css">
  <link rel="stylesheet" type="text/css" media="print" href="public/stylesheets/print.css">
  <link rel="stylesheet" type="text/css" href="public/stylesheets/fonts.css">
  <title>Types</title>
</head>

<body>
  <header>
    <nav id="chapters"><a id="github" href="https://github.com/scala/scala/tree/2.12.x/spec"><img src="public/images/github-logo@2x.png" alt="Edit at GitHub"></a><a href="01-lexical-syntax.html">1 Lexical Syntax</a><a href="02-identifiers-names-and-scopes.html">2 Identifiers, Names & Scopes</a><a href="03-types.html">3 Types</a><a href="04-basic-declarations-and-definitions.html">4 Basic Declarations & Definitions</a><a href="05-classes-and-objects.html">5 Classes & Objects</a><a href="06-expressions.html">6 Expressions</a><a href="07-implicits.html">7 Implicits</a><a href="08-pattern-matching.html">8 Pattern Matching</a><a href="09-top-level-definitions.html">9 Top-Level Definitions</a><a href="10-xml-expressions-and-patterns.html">10 XML</a><a href="11-annotations.html">11 Annotations</a><a href="12-the-scala-standard-library.html">12 Standard Library</a><a href="13-syntax-summary.html">13 Syntax Summary</a><a href="14-references.html">14 References</a><a href="15-changelog.html">15 Changelog</a></nav>
  </header>
  <aside class="left"><nav id="toc"></nav></aside>

  <main id="content">
<h1 id="types">Types</h1>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf">  <a name="Type"></a>Type              ::=  <a href=03-types.html#FunctionArgTypes>FunctionArgTypes</a> ‘=&gt;’ <a href=03-types.html#Type>Type</a>
                      |  <a href=03-types.html#InfixType>InfixType</a> [<a href=03-types.html#ExistentialClause>ExistentialClause</a>]
  <a name="FunctionArgTypes"></a>FunctionArgTypes  ::=  <a href=03-types.html#InfixType>InfixType</a>
                      |  ‘(’ [ <a href=04-basic-declarations-and-definitions.html#ParamType>ParamType</a> {‘,’ <a href=04-basic-declarations-and-definitions.html#ParamType>ParamType</a> } ] ‘)’
  <a name="ExistentialClause"></a>ExistentialClause ::=  ‘forSome’ ‘{’ <a href=03-types.html#ExistentialDcl>ExistentialDcl</a>
                             {<a href=01-lexical-syntax.html#semi>semi</a> <a href=03-types.html#ExistentialDcl>ExistentialDcl</a>} ‘}’
  <a name="ExistentialDcl"></a>ExistentialDcl    ::=  ‘type’ <a href=04-basic-declarations-and-definitions.html#TypeDcl>TypeDcl</a>
                      |  ‘val’ <a href=04-basic-declarations-and-definitions.html#ValDcl>ValDcl</a>
  <a name="InfixType"></a>InfixType         ::=  <a href=03-types.html#CompoundType>CompoundType</a> {<a href=01-lexical-syntax.html#id>id</a> [<t>nl</t>] <a href=03-types.html#CompoundType>CompoundType</a>}
  <a name="CompoundType"></a>CompoundType      ::=  <a href=03-types.html#AnnotType>AnnotType</a> {‘with’ <a href=03-types.html#AnnotType>AnnotType</a>} [<a href=03-types.html#Refinement>Refinement</a>]
                      |  <a href=03-types.html#Refinement>Refinement</a>
  <a name="AnnotType"></a>AnnotType         ::=  <a href=03-types.html#SimpleType>SimpleType</a> {<a href=11-annotations.html#Annotation>Annotation</a>}
  <a name="SimpleType"></a>SimpleType        ::=  <a href=03-types.html#SimpleType>SimpleType</a> <a href=03-types.html#TypeArgs>TypeArgs</a>
                      |  <a href=03-types.html#SimpleType>SimpleType</a> ‘#’ <a href=01-lexical-syntax.html#id>id</a>
                      |  <a href=03-types.html#StableId>StableId</a>
                      |  <a href=03-types.html#Path>Path</a> ‘.’ ‘type’
                      |  ‘(’ <a href=03-types.html#Types>Types</a> ‘)’
  <a name="TypeArgs"></a>TypeArgs          ::=  ‘[’ <a href=03-types.html#Types>Types</a> ‘]’
  <a name="Types"></a>Types             ::=  <a href=03-types.html#Type>Type</a> {‘,’ <a href=03-types.html#Type>Type</a>}
</code></pre></div>
<p>We distinguish between first-order types and type constructors, which
take type parameters and yield types. A subset of first-order types
called <em>value types</em> represents sets of (first-class) values.
Value types are either <em>concrete</em> or <em>abstract</em>.</p>

<p>Every concrete value type can be represented as a <em>class type</em>, i.e. a
<a href="03-types.html#type-designators">type designator</a> that refers to a
<a href="05-classes-and-objects.html#class-definitions">class or a trait</a> <sup id="fnref1"><a href="03-types.html#fn1" rel="footnote">1</a></sup>, or as a
<a href="03-types.html#compound-types">compound type</a> representing an
intersection of types, possibly with a <a href="03-types.html#compound-types">refinement</a>
that further constrains the types of its members.</p>

<!--
A shorthand exists for denoting [function types](#function-types)
-->

<p>Abstract value types are introduced by <a href="04-basic-declarations-and-definitions.html#type-parameters">type parameters</a>
and <a href="04-basic-declarations-and-definitions.html#type-declarations-and-type-aliases">abstract type bindings</a>.
Parentheses in types can be used for grouping.</p>

<p>Non-value types capture properties of identifiers that
<a href="03-types.html#non-value-types">are not values</a>. For example, a
<a href="03-types.html#type-constructors">type constructor</a> does not directly specify a type of
values. However, when a type constructor is applied to the correct type
arguments, it yields a first-order type, which may be a value type.</p>

<p>Non-value types are expressed indirectly in Scala. E.g., a method type is
described by writing down a method signature, which in itself is not a real
type, although it  gives rise to a corresponding <a href="03-types.html#method-types">method type</a>.
Type constructors are another example, as one can write
<code>type Swap[m[_, _], a,b] = m[b, a]</code>, but there is no syntax to write
the corresponding anonymous type function directly.</p>

<h2 id="paths">Paths</h2>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf"><a name="Path"></a>Path            ::=  <a href=03-types.html#StableId>StableId</a>
                  |  [<a href=01-lexical-syntax.html#id>id</a> ‘.’] <t>this</t>
<a name="StableId"></a>StableId        ::=  <a href=01-lexical-syntax.html#id>id</a>
                  |  <a href=03-types.html#Path>Path</a> ‘.’ <a href=01-lexical-syntax.html#id>id</a>
                  |  [<a href=01-lexical-syntax.html#id>id</a> ‘.’] ‘super’ [<a href=03-types.html#ClassQualifier>ClassQualifier</a>] ‘.’ <a href=01-lexical-syntax.html#id>id</a>
<a name="ClassQualifier"></a>ClassQualifier  ::= ‘[’ <a href=01-lexical-syntax.html#id>id</a> ‘]’
</code></pre></div>
<p>Paths are not types themselves, but they can be a part of named types
and in that function form a central role in Scala&#39;s type system.</p>

<p>A path is one of the following.</p>

<ul>
<li>The empty path ε (which cannot be written explicitly in user programs).</li>
<li>$C.$<code>this</code>, where $C$ references a class.
The path <code>this</code> is taken as a shorthand for $C.$<code>this</code> where
$C$ is the name of the class directly enclosing the reference.</li>
<li>$p.x$ where $p$ is a path and $x$ is a stable member of $p$.
<em>Stable members</em> are packages or members introduced by object definitions or
by value definitions of <a href="03-types.html#volatile-types">non-volatile types</a>.</li>
<li>$C.$<code>super</code>$.x$ or $C.$<code>super</code>$[M].x$
where $C$ references a class and $x$ references a
stable member of the super class or designated parent class $M$ of $C$.
The prefix <code>super</code> is taken as a shorthand for $C.$<code>super</code> where
$C$ is the name of the class directly enclosing the reference.</li>
</ul>

<p>A <em>stable identifier</em> is a path which ends in an identifier.</p>

<h2 id="value-types">Value Types</h2>

<p>Every value in Scala has a type which is of one of the following
forms.</p>

<h3 id="singleton-types">Singleton Types</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf"><a name="SimpleType"></a>SimpleType  ::=  <a href=03-types.html#Path>Path</a> ‘.’ <t>type</t>
</code></pre></div>
<p>A <em>singleton type</em> is of the form $p.$<code>type</code>, where $p$ is a
path pointing to a value expected to <a href="06-expressions.html#expression-typing">conform</a>
to <code>scala.AnyRef</code>. The type denotes the set of values
consisting of <code>null</code> and the value denoted by $p$.</p>

<p>A <em>stable type</em> is either a singleton type or a type which is
declared to be a subtype of trait <code>scala.Singleton</code>.</p>

<h3 id="type-projection">Type Projection</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf"><a name="SimpleType"></a>SimpleType  ::=  <a href=03-types.html#SimpleType>SimpleType</a> ‘#’ <a href=01-lexical-syntax.html#id>id</a>
</code></pre></div>
<p>A <em>type projection</em> $T$#$x$ references the type member named
$x$ of type $T$.</p>

<!--
The following is no longer necessary:
If $x$ references an abstract type member, then $T$ must be a
[stable type](#singleton-types)
-->

<h3 id="type-designators">Type Designators</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf"><a name="SimpleType"></a>SimpleType  ::=  <a href=03-types.html#StableId>StableId</a>
</code></pre></div>
<p>A <em>type designator</em> refers to a named value type. It can be simple or
qualified. All such type designators are shorthands for type projections.</p>

<p>Specifically, the unqualified type name $t$ where $t$ is bound in some
class, object, or package $C$ is taken as a shorthand for
$C.$<code>this.type#</code>$t$. If $t$ is
not bound in a class, object, or package, then $t$ is taken as a
shorthand for ε<code>.type#</code>$t$.</p>

<p>A qualified type designator has the form <code>p.t</code> where <code>p</code> is
a <a href="03-types.html#paths">path</a> and <em>t</em> is a type name. Such a type designator is
equivalent to the type projection <code>p.type#t</code>.</p>

<h6 id="example">Example</h6>

<p>Some type designators and their expansions are listed below. We assume
a local type parameter $t$, a value <code>maintable</code>
with a type member <code>Node</code> and the standard class <code>scala.Int</code>,</p>

<table><thead>
<tr>
<th>Designator</th>
<th>Expansion</th>
</tr>
</thead><tbody>
<tr>
<td>t</td>
<td>ε.type#t</td>
</tr>
<tr>
<td>Int</td>
<td>scala.type#Int</td>
</tr>
<tr>
<td>scala.Int</td>
<td>scala.type#Int</td>
</tr>
<tr>
<td>data.maintable.Node</td>
<td>data.maintable.type#Node</td>
</tr>
</tbody></table>

<h3 id="parameterized-types">Parameterized Types</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf"><a name="SimpleType"></a>SimpleType      ::=  <a href=03-types.html#SimpleType>SimpleType</a> <a href=03-types.html#TypeArgs>TypeArgs</a>
<a name="TypeArgs"></a>TypeArgs        ::=  ‘[’ <a href=03-types.html#Types>Types</a> ‘]’
</code></pre></div>
<p>A <em>parameterized type</em> $T[ T_1 , \ldots , T_n ]$ consists of a type
designator $T$ and type parameters $T_1 , \ldots , T_n$ where
$n \geq 1$. $T$ must refer to a type constructor which takes $n$ type
parameters $a_1 , \ldots , a_n$.</p>

<p>Say the type parameters have lower bounds $L_1 , \ldots , L_n$ and
upper bounds $U_1, \ldots, U_n$.  The parameterized type is
well-formed if each actual type parameter
<em>conforms to its bounds</em>, i.e. $\sigma L_i &lt;: T_i &lt;: \sigma U_i$ where $\sigma$ is the
substitution $[ a_1 := T_1 , \ldots , a_n := T_n ]$.</p>

<h6 id="example-parameterized-types">Example Parameterized Types</h6>

<p>Given the partial type definitions:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">class TreeMap[A &lt;: Comparable[A], B] { … }
class List[A] { … }
class I extends Comparable[I] { … }

class F[M[_], X] { … }
class S[K &lt;: String] { … }
class G[M[ Z &lt;: I ], I] { … }
</code></pre></div>
<p>the following parameterized types are well formed:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">TreeMap[I, String]
List[I]
List[List[Boolean]]

F[List, Int]
G[S, String]
</code></pre></div>
<h6 id="example">Example</h6>

<p>Given the <a href="03-types.html#example-parameterized-types">above type definitions</a>,
the following types are ill-formed:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">TreeMap[I]            // illegal: wrong number of parameters
TreeMap[List[I], Int] // illegal: type parameter not within bound

F[Int, Boolean]       // illegal: Int is not a type constructor
F[TreeMap, Int]       // illegal: TreeMap takes two parameters,
                      //   F expects a constructor taking one
G[S, Int]             // illegal: S constrains its parameter to
                      //   conform to String,
                      // G expects type constructor with a parameter
                      //   that conforms to Int
</code></pre></div>
<h3 id="tuple-types">Tuple Types</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf"><a name="SimpleType"></a>SimpleType    ::=   ‘(’ <a href=03-types.html#Types>Types</a> ‘)’
</code></pre></div>
<p>A <em>tuple type</em> $(T_1 , \ldots , T_n)$ is an alias for the
class <code>scala.Tuple$n$[$T_1$, … , $T_n$]</code>, where $n \geq 2$.</p>

<p>Tuple classes are case classes whose fields can be accessed using
selectors <code>_1</code> , … , <code>_n</code>. Their functionality is
abstracted in a corresponding <code>Product</code> trait. The <em>n</em>-ary tuple
class and product trait are defined at least as follows in the
standard Scala library (they might also add other methods and
implement other traits).</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">case class Tuple$n$[+$T_1$, … , +$T_n$](_1: $T_1$, … , _n: $T_n$)
extends Product_n[$T_1$, … , $T_n$]

trait Product_n[+$T_1$, … , +$T_n$] {
  override def productArity = $n$
  def _1: $T_1$
  …
  def _n: $T_n$
}
</code></pre></div>
<h3 id="annotated-types">Annotated Types</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf"><a name="AnnotType"></a>AnnotType  ::=  <a href=03-types.html#SimpleType>SimpleType</a> {<a href=11-annotations.html#Annotation>Annotation</a>}
</code></pre></div>
<p>An <em>annotated type</em> $T$ $a_1, \ldots, a_n$
attaches <a href="11-annotations.html#user-defined-annotations">annotations</a>
$a_1 , \ldots , a_n$ to the type $T$.</p>

<h6 id="example">Example</h6>

<p>The following type adds the <code>@suspendable</code> annotation to the type <code>String</code>:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">String @suspendable
</code></pre></div>
<h3 id="compound-types">Compound Types</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf"><a name="CompoundType"></a>CompoundType    ::=  <a href=03-types.html#AnnotType>AnnotType</a> {‘with’ <a href=03-types.html#AnnotType>AnnotType</a>} [<a href=03-types.html#Refinement>Refinement</a>]
                  |  <a href=03-types.html#Refinement>Refinement</a>
<a name="Refinement"></a>Refinement      ::=  [<t>nl</t>] ‘{’ <a href=03-types.html#RefineStat>RefineStat</a> {<a href=01-lexical-syntax.html#semi>semi</a> <a href=03-types.html#RefineStat>RefineStat</a>} ‘}’
<a name="RefineStat"></a>RefineStat      ::=  <a href=04-basic-declarations-and-definitions.html#Dcl>Dcl</a>
                  |  ‘type’ <a href=04-basic-declarations-and-definitions.html#TypeDef>TypeDef</a>
                  |
</code></pre></div>
<p>A <em>compound type</em> $T_1$ <code>with</code> … <code>with</code> $T_n \{ R \}$
represents objects with members as given in the component types
$T_1 , \ldots , T_n$ and the refinement $\{ R \}$. A refinement
$\{ R \}$ contains declarations and type definitions.
If a declaration or definition overrides a declaration or definition in
one of the component types $T_1 , \ldots , T_n$, the usual rules for
<a href="05-classes-and-objects.html#overriding">overriding</a> apply; otherwise the declaration
or definition is said to be “structural” <sup id="fnref2"><a href="03-types.html#fn2" rel="footnote">2</a></sup>.</p>

<p>Within a method declaration in a structural refinement, the type of
any value parameter may only refer to type parameters or abstract
types that are contained inside the refinement. That is, it must refer
either to a type parameter of the method itself, or to a type
definition within the refinement. This restriction does not apply to
the method&#39;s result type.</p>

<p>If no refinement is given, the empty refinement is implicitly added,
i.e. $T_1$ <code>with</code> … <code>with</code> $T_n$ is a shorthand for $T_1$ <code>with</code> … <code>with</code> $T_n \{\}$.</p>

<p>A compound type may also consist of just a refinement
$\{ R \}$ with no preceding component types. Such a type is
equivalent to <code>AnyRef</code> $\{ R \}$.</p>

<h6 id="example">Example</h6>

<p>The following example shows how to declare and use a method which
a parameter type that contains a refinement with structural declarations.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">case class Bird (val name: String) extends Object {
        def fly(height: Int) = …
…
}
case class Plane (val callsign: String) extends Object {
        def fly(height: Int) = …
…
}
def takeoff(
            runway: Int,
      r: { val callsign: String; def fly(height: Int) }) = {
  tower.print(r.callsign + &quot; requests take-off on runway &quot; + runway)
  tower.read(r.callsign + &quot; is clear for take-off&quot;)
  r.fly(1000)
}
val bird = new Bird(&quot;Polly the parrot&quot;){ val callsign = name }
val a380 = new Plane(&quot;TZ-987&quot;)
takeoff(42, bird)
takeoff(89, a380)
</code></pre></div>
<p>Although <code>Bird</code> and <code>Plane</code> do not share any parent class other than
<code>Object</code>, the parameter <em>r</em> of method <code>takeoff</code> is defined using a
refinement with structural declarations to accept any object that declares
a value <code>callsign</code> and a <code>fly</code> method.</p>

<h3 id="infix-types">Infix Types</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf"><a name="InfixType"></a>InfixType     ::=  <a href=03-types.html#CompoundType>CompoundType</a> {<a href=01-lexical-syntax.html#id>id</a> [<t>nl</t>] <a href=03-types.html#CompoundType>CompoundType</a>}
</code></pre></div>
<p>An <em>infix type</em> $T_1$ <code>op</code> $T_2$ consists of an infix
operator <code>op</code> which gets applied to two type operands $T_1$ and
$T_2$.  The type is equivalent to the type application
<code>op</code>$[T_1, T_2]$.  The infix operator <code>op</code> may be an
arbitrary identifier.</p>

<p>All type infix operators have the same precedence; parentheses have to
be used for grouping. The <a href="06-expressions.html#prefix,-infix,-and-postfix-operations">associativity</a>
of a type operator is determined as for term operators: type operators
ending in a colon ‘:’ are right-associative; all other
operators are left-associative.</p>

<p>In a sequence of consecutive type infix operations
$t_0 \, \mathit{op} \, t_1 \, \mathit{op_2} \, \ldots \, \mathit{op_n} \, t_n$,
all operators $\mathit{op}_1 , \ldots , \mathit{op}_n$ must have the same
associativity. If they are all left-associative, the sequence is
interpreted as
$(\ldots (t_0 \mathit{op_1} t_1) \mathit{op_2} \ldots) \mathit{op_n} t_n$,
otherwise it is interpreted as
$t_0 \mathit{op_1} (t_1 \mathit{op_2} ( \ldots \mathit{op_n} t_n) \ldots)$.</p>

<h3 id="function-types">Function Types</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf"><a name="Type"></a>Type              ::=  <a href=03-types.html#FunctionArgs>FunctionArgs</a> ‘=&gt;’ <a href=03-types.html#Type>Type</a>
<a name="FunctionArgs"></a>FunctionArgs      ::=  <a href=03-types.html#InfixType>InfixType</a>
                    |  ‘(’ [ <a href=04-basic-declarations-and-definitions.html#ParamType>ParamType</a> {‘,’ <a href=04-basic-declarations-and-definitions.html#ParamType>ParamType</a> } ] ‘)’
</code></pre></div>
<p>The type $(T_1 , \ldots , T_n) \Rightarrow U$ represents the set of function
values that take arguments of types $T1 , \ldots , Tn$ and yield
results of type $U$.  In the case of exactly one argument type
$T \Rightarrow U$ is a shorthand for $(T) \Rightarrow U$.
An argument type of the form $\Rightarrow T$
represents a <a href="04-basic-declarations-and-definitions.html#by-name-parameters">call-by-name parameter</a> of type $T$.</p>

<p>Function types associate to the right, e.g.
$S \Rightarrow T \Rightarrow U$ is the same as
$S \Rightarrow (T \Rightarrow U)$.</p>

<p>Function types are shorthands for class types that define <code>apply</code>
functions.  Specifically, the $n$-ary function type
$(T_1 , \ldots , T_n) \Rightarrow U$ is a shorthand for the class type
<code>Function$_n$[T1 , … , $T_n$, U]</code>. Such class
types are defined in the Scala library for $n$ between 0 and 9 as follows.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">package scala
trait Function_n[-T1 , … , -T$_n$, +R] {
  def apply(x1: T1 , … , x$_n$: T$_n$): R
  override def toString = &quot;&lt;function&gt;&quot;
}
</code></pre></div>
<p>Hence, function types are <a href="04-basic-declarations-and-definitions.html#variance-annotations">covariant</a> in their
result type and contravariant in their argument types.</p>

<h3 id="existential-types">Existential Types</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf"><a name="Type"></a>Type               ::= <a href=03-types.html#InfixType>InfixType</a> <a href=03-types.html#ExistentialClauses>ExistentialClauses</a>
<a name="ExistentialClauses"></a>ExistentialClauses ::= ‘forSome’ ‘{’ <a href=03-types.html#ExistentialDcl>ExistentialDcl</a>
                       {<a href=01-lexical-syntax.html#semi>semi</a> <a href=03-types.html#ExistentialDcl>ExistentialDcl</a>} ‘}’
<a name="ExistentialDcl"></a>ExistentialDcl     ::= ‘type’ <a href=04-basic-declarations-and-definitions.html#TypeDcl>TypeDcl</a>
                    |  ‘val’ <a href=04-basic-declarations-and-definitions.html#ValDcl>ValDcl</a>
</code></pre></div>
<p>An <em>existential type</em> has the form <code>$T$ forSome { $Q$ }</code>
where $Q$ is a sequence of
<a href="04-basic-declarations-and-definitions.html#type-declarations-and-type-aliases">type declarations</a>.</p>

<p>Let
$t_1[\mathit{tps}_1] &gt;: L_1 &lt;: U_1 , \ldots , t_n[\mathit{tps}_n] &gt;: L_n &lt;: U_n$
be the types declared in $Q$ (any of the
type parameter sections <code>[ $\mathit{tps}_i$ ]</code> might be missing).
The scope of each type $t_i$ includes the type $T$ and the existential clause
$Q$.
The type variables $t_i$ are said to be <em>bound</em> in the type
<code>$T$ forSome { $Q$ }</code>.
Type variables which occur in a type $T$ but which are not bound in $T$ are said
to be <em>free</em> in $T$.</p>

<p>A <em>type instance</em> of <code>$T$ forSome { $Q$ }</code>
is a type $\sigma T$ where $\sigma$ is a substitution over $t_1 , \ldots , t_n$
such that, for each $i$, $\sigma L_i &lt;: \sigma t_i &lt;: \sigma U_i$.
The set of values denoted by the existential type <code>$T$ forSome {$\,Q\,$}</code>
is the union of the set of values of all its type instances.</p>

<p>A <em>skolemization</em> of <code>$T$ forSome { $Q$ }</code> is
a type instance $\sigma T$, where $\sigma$ is the substitution
$[t_1&#39;/t_1 , \ldots , t_n&#39;/t_n]$ and each $t_i&#39;$ is a fresh abstract type
with lower bound $\sigma L_i$ and upper bound $\sigma U_i$.</p>

<h4 id="simplification-rules">Simplification Rules</h4>

<p>Existential types obey the following four equivalences:</p>

<ol>
<li>Multiple for-clauses in an existential type can be merged. E.g.,
<code>$T$ forSome { $Q$ } forSome { $Q&#39;$ }</code>
is equivalent to
<code>$T$ forSome { $Q$ ; $Q&#39;$}</code>.</li>
<li>Unused quantifications can be dropped. E.g.,
<code>$T$ forSome { $Q$ ; $Q&#39;$}</code>
where none of the types defined in $Q&#39;$ are referred to by $T$ or $Q$,
is equivalent to
<code>$T$ forSome {$ Q $}</code>.</li>
<li>An empty quantification can be dropped. E.g.,
<code>$T$ forSome { }</code> is equivalent to $T$.</li>
<li>An existential type <code>$T$ forSome { $Q$ }</code> where $Q$ contains
a clause <code>type $t[\mathit{tps}] &gt;: L &lt;: U$</code> is equivalent
to the type <code>$T&#39;$ forSome { $Q$ }</code> where $T&#39;$ results from $T$ by replacing
every <a href="04-basic-declarations-and-definitions.html#variance-annotations">covariant occurrence</a> of $t$ in $T$ by $U$ and by
replacing every contravariant occurrence of $t$ in $T$ by $L$.</li>
</ol>

<h4 id="existential-quantification-over-values">Existential Quantification over Values</h4>

<p>As a syntactic convenience, the bindings clause
in an existential type may also contain
value declarations <code>val $x$: $T$</code>.
An existential type <code>$T$ forSome { $Q$; val $x$: $S\,$;$\,Q&#39;$ }</code>
is treated as a shorthand for the type
<code>$T&#39;$ forSome { $Q$; type $t$ &lt;: $S$ with Singleton; $Q&#39;$ }</code>, where $t$ is a
fresh type name and $T&#39;$ results from $T$ by replacing every occurrence of
<code>$x$.type</code> with $t$.</p>

<h4 id="placeholder-syntax-for-existential-types">Placeholder Syntax for Existential Types</h4>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf"><a name="WildcardType"></a>WildcardType   ::=  ‘_’ <t>TypeBounds</t>
</code></pre></div>
<p>Scala supports a placeholder syntax for existential types.
A <em>wildcard type</em> is of the form <code>_$\;$&gt;:$\,L\,$&lt;:$\,U$</code>. Both bound
clauses may be omitted. If a lower bound clause <code>&gt;:$\,L$</code> is missing,
<code>&gt;:$\,$scala.Nothing</code>
is assumed. If an upper bound clause <code>&lt;:$\,U$</code> is missing,
<code>&lt;:$\,$scala.Any</code> is assumed. A wildcard type is a shorthand for an
existentially quantified type variable, where the existential quantification is
implicit.</p>

<p>A wildcard type must appear as type argument of a parameterized type.
Let $T = p.c[\mathit{targs},T,\mathit{targs}&#39;]$ be a parameterized type where
$\mathit{targs}, \mathit{targs}&#39;$ may be empty and
$T$ is a wildcard type <code>_$\;$&gt;:$\,L\,$&lt;:$\,U$</code>. Then $T$ is equivalent to the
existential
type</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">$p.c[\mathit{targs},t,\mathit{targs}&#39;]$ forSome { type $t$ &gt;: $L$ &lt;: $U$ }
</code></pre></div>
<p>where $t$ is some fresh type variable.
Wildcard types may also appear as parts of <a href="03-types.html#infix-types">infix types</a>
, <a href="03-types.html#function-types">function types</a>,
or <a href="03-types.html#tuple-types">tuple types</a>.
Their expansion is then the expansion in the equivalent parameterized
type.</p>

<h6 id="example">Example</h6>

<p>Assume the class definitions</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">class Ref[T]
abstract class Outer { type T } .
</code></pre></div>
<p>Here are some examples of existential types:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">Ref[T] forSome { type T &lt;: java.lang.Number }
Ref[x.T] forSome { val x: Outer }
Ref[x_type # T] forSome { type x_type &lt;: Outer with Singleton }
</code></pre></div>
<p>The last two types in this list are equivalent.
An alternative formulation of the first type above using wildcard syntax is:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">Ref[_ &lt;: java.lang.Number]
</code></pre></div>
<h6 id="example">Example</h6>

<p>The type <code>List[List[_]]</code> is equivalent to the existential type</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">List[List[t] forSome { type t }] .
</code></pre></div>
<h6 id="example">Example</h6>

<p>Assume a covariant type</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">class List[+T]
</code></pre></div>
<p>The type</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">List[T] forSome { type T &lt;: java.lang.Number }
</code></pre></div>
<p>is equivalent (by simplification rule 4 above) to</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">List[java.lang.Number] forSome { type T &lt;: java.lang.Number }
</code></pre></div>
<p>which is in turn equivalent (by simplification rules 2 and 3 above) to
<code>List[java.lang.Number]</code>.</p>

<h2 id="non-value-types">Non-Value Types</h2>

<p>The types explained in the following do not denote sets of values, nor
do they appear explicitly in programs. They are introduced in this
report as the internal types of defined identifiers.</p>

<h3 id="method-types">Method Types</h3>

<p>A <em>method type</em> is denoted internally as $(\mathit{Ps})U$, where $(\mathit{Ps})$
is a sequence of parameter names and types $(p_1:T_1 , \ldots , p_n:T_n)$
for some $n \geq 0$ and $U$ is a (value or method) type.  This type
represents named methods that take arguments named $p_1 , \ldots , p_n$
of types $T_1 , \ldots , T_n$
and that return a result of type $U$.</p>

<p>Method types associate to the right: $(\mathit{Ps}_1)(\mathit{Ps}_2)U$ is
treated as $(\mathit{Ps}_1)((\mathit{Ps}_2)U)$.</p>

<p>A special case are types of methods without any parameters. They are
written here <code>=&gt; T</code>. Parameterless methods name expressions
that are re-evaluated each time the parameterless method name is
referenced.</p>

<p>Method types do not exist as types of values. If a method name is used
as a value, its type is <a href="06-expressions.html#implicit-conversions">implicitly converted</a> to a
corresponding function type.</p>

<h6 id="example">Example</h6>

<p>The declarations</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">def a: Int
def b (x: Int): Boolean
def c (x: Int) (y: String, z: String): String
</code></pre></div>
<p>produce the typings</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">a: =&gt; Int
b: (Int) Boolean
c: (Int) (String, String) String
</code></pre></div>
<h3 id="polymorphic-method-types">Polymorphic Method Types</h3>

<p>A polymorphic method type is denoted internally as <code>[$\mathit{tps}\,$]$T$</code> where
<code>[$\mathit{tps}\,$]</code> is a type parameter section
<code>[$a_1$ &gt;: $L_1$ &lt;: $U_1 , \ldots , a_n$ &gt;: $L_n$ &lt;: $U_n$]</code>
for some $n \geq 0$ and $T$ is a
(value or method) type.  This type represents named methods that
take type arguments <code>$S_1 , \ldots , S_n$</code> which
<a href="03-types.html#parameterized-types">conform</a> to the lower bounds
<code>$L_1 , \ldots , L_n$</code> and the upper bounds
<code>$U_1 , \ldots , U_n$</code> and that yield results of type $T$.</p>

<h6 id="example">Example</h6>

<p>The declarations</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">def empty[A]: List[A]
def union[A &lt;: Comparable[A]] (x: Set[A], xs: Set[A]): Set[A]
</code></pre></div>
<p>produce the typings</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">empty : [A &gt;: Nothing &lt;: Any] List[A]
union : [A &gt;: Nothing &lt;: Comparable[A]] (x: Set[A], xs: Set[A]) Set[A]
</code></pre></div>
<h3 id="type-constructors">Type Constructors</h3>

<p>A <em>type constructor</em> is represented internally much like a polymorphic method type.
<code>[$\pm$ $a_1$ &gt;: $L_1$ &lt;: $U_1 , \ldots , \pm a_n$ &gt;: $L_n$ &lt;: $U_n$] $T$</code>
represents a type that is expected by a
<a href="04-basic-declarations-and-definitions.html#type-parameters">type constructor parameter</a> or an
<a href="04-basic-declarations-and-definitions.html#type-declarations-and-type-aliases">abstract type constructor binding</a> with
the corresponding type parameter clause.</p>

<h6 id="example">Example</h6>

<p>Consider this fragment of the <code>Iterable[+X]</code> class:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">trait Iterable[+X] {
  def flatMap[newType[+X] &lt;: Iterable[X], S](f: X =&gt; newType[S]): newType[S]
}
</code></pre></div>
<p>Conceptually, the type constructor <code>Iterable</code> is a name for the
anonymous type <code>[+X] Iterable[X]</code>, which may be passed to the
<code>newType</code> type constructor parameter in <code>flatMap</code>.</p>

<!-- ### Overloaded Types

More than one values or methods are defined in the same scope with the
same name, we model

An overloaded type consisting of type alternatives $T_1 \commadots T_n (n \geq 2)$ is denoted internally $T_1 \overload \ldots \overload T_n$.

###### Example
```
def println: Unit
def println(s: String): Unit = $\ldots$
def println(x: Float): Unit = $\ldots$
def println(x: Float, width: Int): Unit = $\ldots$
def println[A](x: A)(tostring: A => String): Unit = $\ldots$
```
define a single function `println` which has an overloaded
type.
```
println:  => Unit $\overload$
          (String) Unit $\overload$
          (Float) Unit $\overload$
          (Float, Int) Unit $\overload$
          [A] (A) (A => String) Unit
```

###### Example
```
def f(x: T): T = $\ldots$
val f = 0
```
define a function `f} which has type `(x: T)T $\overload$ Int`.
-->

<h2 id="base-types-and-member-definitions">Base Types and Member Definitions</h2>

<p>Types of class members depend on the way the members are referenced.
Central here are three notions, namely:</p>

<ol>
<li>the notion of the set of base types of a type $T$,</li>
<li>the notion of a type $T$ in some class $C$ seen from some
prefix type $S$,</li>
<li>the notion of the set of member bindings of some type $T$.</li>
</ol>

<p>These notions are defined mutually recursively as follows.</p>

<ol>
<li><p>The set of <em>base types</em> of a type is a set of class types,
given as follows.</p>

<ul>
<li>The base types of a class type $C$ with parents $T_1 , \ldots , T_n$ are
$C$ itself, as well as the base types of the compound type
<code>$T_1$ with … with $T_n$ { $R$ }</code>.</li>
<li>The base types of an aliased type are the base types of its alias.</li>
<li>The base types of an abstract type are the base types of its upper bound.</li>
<li>The base types of a parameterized type
<code>$C$[$T_1 , \ldots , T_n$]</code> are the base types
of type $C$, where every occurrence of a type parameter $a_i$
of $C$ has been replaced by the corresponding parameter type $T_i$.</li>
<li>The base types of a singleton type <code>$p$.type</code> are the base types of
the type of $p$.</li>
<li>The base types of a compound type
<code>$T_1$ with $\ldots$ with $T_n$ { $R$ }</code>
are the <em>reduced union</em> of the base
classes of all $T_i$&#39;s. This means:
Let the multi-set $\mathscr{S}$ be the multi-set-union of the
base types of all $T_i$&#39;s.
If $\mathscr{S}$ contains several type instances of the same class, say
<code>$S^i$#$C$[$T^i_1 , \ldots , T^i_n$]</code> $(i \in I)$, then
all those instances
are replaced by one of them which conforms to all
others. It is an error if no such instance exists. It follows that the
reduced union, if it exists,
produces a set of class types, where different types are instances of
different classes.</li>
<li>The base types of a type selection <code>$S$#$T$</code> are
determined as follows. If $T$ is an alias or abstract type, the
previous clauses apply. Otherwise, $T$ must be a (possibly
parameterized) class type, which is defined in some class $B$.  Then
the base types of <code>$S$#$T$</code> are the base types of $T$
in $B$ seen from the prefix type $S$.</li>
<li>The base types of an existential type <code>$T$ forSome { $Q$ }</code> are
all types <code>$S$ forSome { $Q$ }</code> where $S$ is a base type of $T$.</li>
</ul></li>
<li><p>The notion of a type $T$ <em>in class $C$ seen from some prefix type $S$</em>
makes sense only if the prefix type $S$
has a type instance of class $C$ as a base type, say
<code>$S&#39;$#$C$[$T_1 , \ldots , T_n$]</code>. Then we define as follows.</p>

<ul>
<li>If <code>$S$ = $\epsilon$.type</code>, then $T$ in $C$ seen from $S$ is
$T$ itself.</li>
<li>Otherwise, if $S$ is an existential type <code>$S&#39;$ forSome { $Q$ }</code>, and
$T$ in $C$ seen from $S&#39;$ is $T&#39;$,
then $T$ in $C$ seen from $S$ is <code>$T&#39;$ forSome {$\,Q\,$}</code>.</li>
<li>Otherwise, if $T$ is the $i$&#39;th type parameter of some class $D$, then

<ul>
<li>If $S$ has a base type <code>$D$[$U_1 , \ldots , U_n$]</code>, for some type
parameters <code>[$U_1 , \ldots , U_n$]</code>, then $T$ in $C$ seen from $S$
is $U_i$.</li>
<li>Otherwise, if $C$ is defined in a class $C&#39;$, then
$T$ in $C$ seen from $S$ is the same as $T$ in $C&#39;$ seen from $S&#39;$.</li>
<li>Otherwise, if $C$ is not defined in another class, then
$T$ in $C$ seen from $S$ is $T$ itself.</li>
</ul></li>
<li>Otherwise, if $T$ is the singleton type <code>$D$.this.type</code> for some class $D$
then

<ul>
<li>If $D$ is a subclass of $C$ and $S$ has a type instance of class $D$
among its base types, then $T$ in $C$ seen from $S$ is $S$.</li>
<li>Otherwise, if $C$ is defined in a class $C&#39;$, then
$T$ in $C$ seen from $S$ is the same as $T$ in $C&#39;$ seen from $S&#39;$.</li>
<li>Otherwise, if $C$ is not defined in another class, then
$T$ in $C$ seen from $S$ is $T$ itself.</li>
</ul></li>
<li>If $T$ is some other type, then the described mapping is performed
to all its type components.</li>
</ul>

<p>If $T$ is a possibly parameterized class type, where $T$&#39;s class
is defined in some other class $D$, and $S$ is some prefix type,
then we use &quot;$T$ seen from $S$&quot; as a shorthand for
&quot;$T$ in $D$ seen from $S$&quot;.</p></li>
<li><p>The <em>member bindings</em> of a type $T$ are</p>

<ol>
<li>all bindings $d$ such that there exists a type instance of some class $C$ among the base types of $T$
and there exists a definition or declaration $d&#39;$ in $C$
such that $d$ results from $d&#39;$ by replacing every
type $T&#39;$ in $d&#39;$ by $T&#39;$ in $C$ seen from $T$, and</li>
<li>all bindings of the type&#39;s <a href="03-types.html#compound-types">refinement</a>, if it has one.</li>
</ol></li>
</ol>

<p>The <em>definition</em> of a type projection <code>S#T</code> is the member
   binding $d_T$ of the type <code>T</code> in <code>S</code>. In that case, we also say
   that <code>S#T</code> <em>is defined by</em> $d_T$.</p>

<h2 id="relations-between-types">Relations between types</h2>

<p>We define the following relations between types.</p>

<table><thead>
<tr>
<th>Name</th>
<th>Symbolically</th>
<th>Interpretation</th>
</tr>
</thead><tbody>
<tr>
<td>Equivalence</td>
<td>$T \equiv U$</td>
<td>$T$ and $U$ are interchangeable in all contexts.</td>
</tr>
<tr>
<td>Conformance</td>
<td>$T &lt;: U$</td>
<td>Type $T$ conforms to (&quot;is a subtype of&quot;) type $U$.</td>
</tr>
<tr>
<td>Weak Conformance</td>
<td>$T &lt;:_w U$</td>
<td>Augments conformance for primitive numeric types.</td>
</tr>
<tr>
<td>Compatibility</td>
<td></td>
<td>Type $T$ conforms to type $U$ after conversions.</td>
</tr>
</tbody></table>

<h3 id="equivalence">Equivalence</h3>

<p>Equivalence $(\equiv)$ between types is the smallest congruence <sup id="fnref3"><a href="03-types.html#fn3" rel="footnote">3</a></sup> such that the following holds:</p>

<ul>
<li>If $t$ is defined by a type alias <code>type $t$ = $T$</code>, then $t$ is equivalent to $T$.</li>
<li>If a path $p$ has a singleton type <code>$q$.type</code>, then <code>$p$.type $\equiv q$.type</code>.</li>
<li>If $O$ is defined by an object definition, and $p$ is a path consisting only of package or object selectors and ending in $O$, then <code>$O$.this.type $\equiv p$.type</code>.</li>
<li>Two <a href="03-types.html#compound-types">compound types</a> are equivalent if the sequences
of their component are pairwise equivalent, and occur in the same order, and
their refinements are equivalent. Two refinements are equivalent if they
bind the same names and the modifiers, types and bounds of every
declared entity are equivalent in both refinements.</li>
<li>Two <a href="03-types.html#method-types">method types</a> are equivalent if:

<ul>
<li>neither are implicit, or they both are <sup id="fnref4"><a href="03-types.html#fn4" rel="footnote">4</a></sup>;</li>
<li>they have equivalent result types;</li>
<li>they have the same number of parameters; and</li>
<li>corresponding parameters have equivalent types.
Note that the names of parameters do not matter for method type equivalence.</li>
</ul></li>
<li>Two <a href="03-types.html#polymorphic-method-types">polymorphic method types</a> are equivalent if
they have the same number of type parameters, and, after renaming one set of
type parameters by another, the result types as well as lower and upper bounds
of corresponding type parameters are equivalent.</li>
<li>Two <a href="03-types.html#existential-types">existential types</a>
are equivalent if they have the same number of
quantifiers, and, after renaming one list of type quantifiers by
another, the quantified types as well as lower and upper bounds of
corresponding quantifiers are equivalent.</li>
<li>Two <a href="03-types.html#type-constructors">type constructors</a> are equivalent if they have the
same number of type parameters, and, after renaming one list of type
parameters by another, the result types as well as variances, lower and upper
bounds of corresponding type parameters are equivalent.</li>
</ul>

<h3 id="conformance">Conformance</h3>

<p>The conformance relation $(&lt;:)$ is the smallest transitive relation that satisfies the following conditions.</p>

<ul>
<li>Conformance includes equivalence. If $T \equiv U$ then $T &lt;: U$.</li>
<li>For every value type $T$, <code>scala.Nothing &lt;: $T$ &lt;: scala.Any</code>.</li>
<li>For every type constructor $T$ (with any number of type parameters), <code>scala.Nothing &lt;: $T$ &lt;: scala.Any</code>.</li>
<li>For every class type $T$ such that <code>$T$ &lt;: scala.AnyRef</code> one has <code>scala.Null &lt;: $T$</code>.</li>
<li>A type variable or abstract type $t$ conforms to its upper bound and
its lower bound conforms to $t$.</li>
<li>A class type or parameterized type conforms to any of its base-types.</li>
<li>A singleton type <code>$p$.type</code> conforms to the type of the path $p$.</li>
<li>A singleton type <code>$p$.type</code> conforms to the type <code>scala.Singleton</code>.</li>
<li>A type projection <code>$T$#$t$</code> conforms to <code>$U$#$t$</code> if $T$ conforms to $U$.</li>
<li>A parameterized type <code>$T$[$T_1$ , … , $T_n$]</code> conforms to
<code>$T$[$U_1$ , … , $U_n$]</code> if
the following three conditions hold for $i \in { 1 , \ldots , n }$:

<ol>
<li>If the $i$&#39;th type parameter of $T$ is declared covariant, then
$T_i &lt;: U_i$.</li>
<li>If the $i$&#39;th type parameter of $T$ is declared contravariant, then
$U_i &lt;: T_i$.</li>
<li>If the $i$&#39;th type parameter of $T$ is declared neither covariant
nor contravariant, then $U_i \equiv T_i$.</li>
</ol></li>
<li>A compound type <code>$T_1$ with $\ldots$ with $T_n$ {$R\,$}</code> conforms to
each of its component types $T_i$.</li>
<li>If $T &lt;: U_i$ for $i \in { 1 , \ldots , n }$ and for every
binding $d$ of a type or value $x$ in $R$ there exists a member
binding of $x$ in $T$ which subsumes $d$, then $T$ conforms to the
compound type <code>$U_1$ with $\ldots$ with $U_n$ {$R\,$}</code>.</li>
<li>The existential type <code>$T$ forSome {$\,Q\,$}</code> conforms to
$U$ if its <a href="03-types.html#existential-types">skolemization</a>
conforms to $U$.</li>
<li>The type $T$ conforms to the existential type <code>$U$ forSome {$\,Q\,$}</code>
if $T$ conforms to one of the <a href="03-types.html#existential-types">type instances</a>
of <code>$U$ forSome {$\,Q\,$}</code>.</li>
<li>If
$T_i \equiv T_i&#39;$ for $i \in { 1 , \ldots , n}$ and $U$ conforms to $U&#39;$
then the method type $(p_1:T_1 , \ldots , p_n:T_n) U$ conforms to
$(p_1&#39;:T_1&#39; , \ldots , p_n&#39;:T_n&#39;) U&#39;$.</li>
<li>The polymorphic type
$[a_1 &gt;: L_1 &lt;: U_1 , \ldots , a_n &gt;: L_n &lt;: U_n] T$ conforms to the
polymorphic type
$[a_1 &gt;: L_1&#39; &lt;: U_1&#39; , \ldots , a_n &gt;: L_n&#39; &lt;: U_n&#39;] T&#39;$ if, assuming
$L_1&#39; &lt;: a_1 &lt;: U_1&#39; , \ldots , L_n&#39; &lt;: a_n &lt;: U_n&#39;$
one has $T &lt;: T&#39;$ and $L_i &lt;: L_i&#39;$ and $U_i&#39; &lt;: U_i$
for $i \in { 1 , \ldots , n }$.</li>
<li>Type constructors $T$ and $T&#39;$ follow a similar discipline. We characterize
$T$ and $T&#39;$ by their type parameter clauses
$[a_1 , \ldots , a_n]$ and
$[a_1&#39; , \ldots , a_n&#39;]$, where an $a_i$ or $a_i&#39;$ may include a variance
annotation, a higher-order type parameter clause, and bounds. Then, $T$
conforms to $T&#39;$ if any list $[t_1 , \ldots , t_n]$ -- with declared
variances, bounds and higher-order type parameter clauses -- of valid type
arguments for $T&#39;$ is also a valid list of type arguments for $T$ and
$T[t_1 , \ldots , t_n] &lt;: T&#39;[t_1 , \ldots , t_n]$. Note that this entails
that:

<ul>
<li>The bounds on $a_i$ must be weaker than the corresponding bounds declared
for $a&#39;_i$.</li>
<li>The variance of $a_i$ must match the variance of $a&#39;_i$, where covariance
matches covariance, contravariance matches contravariance and any variance
matches invariance.</li>
<li>Recursively, these restrictions apply to the corresponding higher-order
type parameter clauses of $a_i$ and $a&#39;_i$.</li>
</ul></li>
</ul>

<p>A declaration or definition in some compound type of class type $C$
<em>subsumes</em> another declaration of the same name in some compound type or class
type $C&#39;$, if one of the following holds.</p>

<ul>
<li>A value declaration or definition that defines a name $x$ with type $T$
subsumes a value or method declaration that defines $x$ with type $T&#39;$, provided
$T &lt;: T&#39;$.</li>
<li>A method declaration or definition that defines a name $x$ with type $T$
subsumes a method declaration that defines $x$ with type $T&#39;$, provided
$T &lt;: T&#39;$.</li>
<li>A type alias
<code>type $t$[$T_1$ , … , $T_n$] = $T$</code> subsumes a type alias
<code>type $t$[$T_1$ , … , $T_n$] = $T&#39;$</code> if $T \equiv T&#39;$.</li>
<li>A type declaration <code>type $t$[$T_1$ , … , $T_n$] &gt;: $L$ &lt;: $U$</code> subsumes
a type declaration <code>type $t$[$T_1$ , … , $T_n$] &gt;: $L&#39;$ &lt;: $U&#39;$</code> if
$L&#39; &lt;: L$ and $U &lt;: U&#39;$.</li>
<li>A type or class definition that binds a type name $t$ subsumes an abstract
type declaration <code>type t[$T_1$ , … , $T_n$] &gt;: L &lt;: U</code> if
$L &lt;: t &lt;: U$.</li>
</ul>

<h4 id="least-upper-bounds-and-greatest-lower-bounds">Least upper bounds and greatest lower bounds</h4>

<p>The $(&lt;:)$ relation forms pre-order between types, i.e. it is transitive and reflexive.
This allows us to define <em>least upper bounds</em> and <em>greatest lower bounds</em> of a set of types in terms of that order.
The least upper bound or greatest lower bound of a set of types does not always exist.
For instance, consider the class definitions:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">class A[+T] {}
class B extends A[B]
class C extends A[C]
</code></pre></div>
<p>Then the types <code>A[Any], A[A[Any]], A[A[A[Any]]], ...</code> form
a descending sequence of upper bounds for <code>B</code> and <code>C</code>. The
least upper bound would be the infinite limit of that sequence, which
does not exist as a Scala type. Since cases like this are in general
impossible to detect, a Scala compiler is free to reject a term
which has a type specified as a least upper or greatest lower bound,
and that bound would be more complex than some compiler-set
limit <sup id="fnref5"><a href="03-types.html#fn5" rel="footnote">5</a></sup>.</p>

<p>The least upper bound or greatest lower bound might also not be
unique. For instance <code>A with B</code> and <code>B with A</code> are both
greatest lower bounds of <code>A</code> and <code>B</code>. If there are several
least upper bounds or greatest lower bounds, the Scala compiler is
free to pick any one of them.</p>

<h3 id="weak-conformance">Weak Conformance</h3>

<p>In some situations Scala uses a more general conformance relation.
A type $S$ <em>weakly conforms</em> to a type $T$, written $S &lt;:_w T$,
if $S &lt;: T$ or both $S$ and $T$ are primitive number types and $S$ precedes $T$ in the following ordering.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">Byte  $&lt;:_w$ Short
Short $&lt;:_w$ Int
Char  $&lt;:_w$ Int
Int   $&lt;:_w$ Long
Long  $&lt;:_w$ Float
Float $&lt;:_w$ Double
</code></pre></div>
<p>A <em>weak least upper bound</em> is a least upper bound with respect to weak conformance.</p>

<h3 id="compatibility">Compatibility</h3>

<p>A type $T$ is <em>compatible</em> to a type $U$ if $T$ (or its corresponding function type) <a href="03-types.html#weak-conformance">weakly conforms</a> to $U$
after applying <a href="06-expressions.html#eta-expansion">eta-expansion</a>. If $T$ is a method type, it&#39;s converted to the corresponding function type. If the types do not weakly conform, the following alternatives are checked in order:</p>

<ul>
<li><a href="07-implicits.html#views">view application</a>: there&#39;s an implicit view from $T$ to $U$;</li>
<li>dropping by-name modifiers: if $U$ is of the shape <code>$=&gt; U&#39;$</code> (and $T$ is not), <code>$T &lt;:_w U&#39;$</code>;</li>
<li>SAM conversion: if $T$ corresponds to a function type, and $U$ declares a single abstract method whose type <a href="06-expressions.html#sam-conversion">corresponds</a> to the function type $U&#39;$, <code>$T &lt;:_w U&#39;$</code>.</li>
</ul>

<!--- TODO: include other implicit conversions in addition to view application?

  trait Proc { def go(x: Any): Unit }

  def foo(x: Any => Unit): Unit = ???
  def foo(x: Proc): Unit = ???

  foo((x: Any) => 1) // works when you drop either foo overload since value discarding is applied

-->

<h4 id="examples">Examples</h4>

<h5 id="function-compatibility-via-sam-conversion">Function compatibility via SAM conversion</h5>

<p>Given the definitions</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">def foo(x: Int =&gt; String): Unit
def foo(x: ToString): Unit

trait ToString { def convert(x: Int): String }
</code></pre></div>
<p>The application <code>foo((x: Int) =&gt; x.toString)</code> <a href="06-expressions.html#overloading-resolution">resolves</a> to the first overload,
as it&#39;s more specific:</p>

<ul>
<li><code>Int =&gt; String</code> is compatible to <code>ToString</code> -- when expecting a value of type <code>ToString</code>, you may pass a function literal from <code>Int</code> to <code>String</code>, as it will be SAM-converted to said function;</li>
<li><code>ToString</code> is not compatible to <code>Int =&gt; String</code> -- when expecting a function from <code>Int</code> to <code>String</code>, you may not pass a <code>ToString</code>.</li>
</ul>

<h2 id="volatile-types">Volatile Types</h2>

<p>Type volatility approximates the possibility that a type parameter or
abstract type instance of a type does not have any non-null values.
A value member of a volatile type cannot appear in a <a href="03-types.html#paths">path</a>.</p>

<p>A type is <em>volatile</em> if it falls into one of four categories:</p>

<p>A compound type <code>$T_1$ with … with $T_n$ {$R\,$}</code>
is volatile if one of the following two conditions hold.</p>

<ol>
<li>One of $T_2 , \ldots , T_n$ is a type parameter or abstract type, or</li>
<li>$T_1$ is an abstract type and and either the refinement $R$
or a type $T_j$ for $j &gt; 1$ contributes an abstract member
to the compound type, or</li>
<li>one of $T_1 , \ldots , T_n$ is a singleton type.</li>
</ol>

<p>Here, a type $S$ <em>contributes an abstract member</em> to a type $T$ if
$S$ contains an abstract member that is also a member of $T$.
A refinement $R$ contributes an abstract member to a type $T$ if $R$
contains an abstract declaration which is also a member of $T$.</p>

<p>A type designator is volatile if it is an alias of a volatile type, or
if it designates a type parameter or abstract type that has a volatile type as
its upper bound.</p>

<p>A singleton type <code>$p$.type</code> is volatile, if the underlying
type of path $p$ is volatile.</p>

<p>An existential type <code>$T$ forSome {$\,Q\,$}</code> is volatile if
$T$ is volatile.</p>

<h2 id="type-erasure">Type Erasure</h2>

<p>A type is called <em>generic</em> if it contains type arguments or type variables.
<em>Type erasure</em> is a mapping from (possibly generic) types to
non-generic types. We write $|T|$ for the erasure of type $T$.
The erasure mapping is defined as follows.</p>

<ul>
<li>The erasure of an alias type is the erasure of its right-hand side.</li>
<li>The erasure of an abstract type is the erasure of its upper bound.</li>
<li>The erasure of the parameterized type <code>scala.Array$[T_1]$</code> is
<code>scala.Array$[|T_1|]$</code>.</li>
<li>The erasure of every other parameterized type $T[T_1 , \ldots , T_n]$ is $|T|$.</li>
<li>The erasure of a singleton type <code>$p$.type</code> is the
erasure of the type of $p$.</li>
<li>The erasure of a type projection <code>$T$#$x$</code> is <code>|$T$|#$x$</code>.</li>
<li>The erasure of a compound type
<code>$T_1$ with $\ldots$ with $T_n$ {$R\,$}</code> is the erasure of the intersection
dominator of $T_1 , \ldots , T_n$.</li>
<li>The erasure of an existential type <code>$T$ forSome {$\,Q\,$}</code> is $|T|$.</li>
</ul>

<p>The <em>intersection dominator</em> of a list of types $T_1 , \ldots , T_n$ is computed
as follows.
Let $T_{i_1} , \ldots , T_{i_m}$ be the subsequence of types $T_i$
which are not supertypes of some other type $T_j$.
If this subsequence contains a type designator $T_c$ that refers to a class
which is not a trait,
the intersection dominator is $T_c$. Otherwise, the intersection
dominator is the first element of the subsequence, $T_{i_1}$.</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>We assume that objects and packages also implicitly
  define a class (of the same name as the object or package, but
  inaccessible to user programs).&nbsp;<a href="03-types.html#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>A reference to a structurally defined member (method call or access
  to a value or variable) may generate binary code that is significantly
  slower than an equivalent code to a non-structural member.&nbsp;<a href="03-types.html#fnref2" rev="footnote">&#8617;</a></p>
</li>

<li id="fn3">
<p>A congruence is an equivalence relation which is closed under formation of contexts.&nbsp;<a href="03-types.html#fnref3" rev="footnote">&#8617;</a></p>
</li>

<li id="fn4">
<p>A method type is implicit if the parameter section that defines it starts with the <code>implicit</code> keyword.&nbsp;<a href="03-types.html#fnref4" rev="footnote">&#8617;</a></p>
</li>

<li id="fn5">
<p>The current Scala compiler limits the nesting level
  of parameterization in such bounds to be at most two deeper than the
  maximum nesting level of the operand types&nbsp;<a href="03-types.html#fnref5" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

  </main>

  <script src="public/scripts/toc.js"></script>
  <script src="public/scripts/highlight.pack.js"></script>
  <script src="public/scripts/main.js"></script>
</body>
</html>
