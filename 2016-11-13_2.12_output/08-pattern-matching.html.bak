<!DOCTYPE html>
<html>
<head>
  <meta http-equiv='Content-Type' content='text/html; charset=utf-8' />

  <link rel="icon" type="image/png" href="public/favicon.ico">
  <link rel="shortcut icon" type="image/png" href="public/favicon.ico">

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      skipTags: ['script', 'noscript', 'style', 'textarea'],
      processEscapes: true
    }
  });
  </script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script src="http://code.jquery.com/jquery-2.1.3.min.js"></script>
  <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.2/styles/default.min.css">
  <!-- need to use include to see value of page.chapter variable -->
  <style type="text/css">
    h1 {
  /* must reset here */
  counter-reset: chapter 8;
}
h1:before {
  /* and must reset again here */
  counter-reset: chapter 8;
  content: "Chapter " counter(chapter);
  display: block;
}

h2 {
  /* must increment here */
  counter-increment: section;
  counter-reset: subsection;
}
h2:before {
  /* and must reset again here */
  counter-reset: chapter 8;

  content: counter(chapter) "." counter(section) ;
  display: inline;
  margin-right: 1em;
}
h2:after {
  /* can only have one counter-reset per tag, so can't do it in h2/h2:before... */
  counter-reset: example;
}

h3 {
  /* must increment here */
  counter-increment: subsection;
}
h3:before {
  /* and must reset again here */
  counter-reset: chapter 8;

  content: counter(chapter) "." counter(section) "." counter(subsection);
  display: inline;
  margin-right: 1em;
}
h3[id*='example'] {
  /* must increment here */
  counter-increment: example;
  display: inline;
}
h3[id*='example']:before {
  /* and must reset again here */
  counter-reset: chapter 8;

  content: "Example " counter(chapter) "." counter(section) "." counter(example);
  display: inline;
  margin-right: 1em;
}

.no-numbering, .no-numbering:before, .no-numbering:after {
  content: normal;
  counter-reset: none;
  counter-increment: none;
}

  </style>
  <link rel="stylesheet" type="text/css" href="public/stylesheets/screen.css">
  <link rel="stylesheet" type="text/css" media="(max-width: 1400px), (orientation: portrait)" href="public/stylesheets/screen-small.css">
  <link rel="stylesheet" type="text/css" media="print" href="public/stylesheets/print.css">
  <link rel="stylesheet" type="text/css" href="public/stylesheets/fonts.css">
  <title>Pattern Matching</title>
</head>

<body>
  <header>
    <nav id="chapters"><a id="github" href="https://github.com/scala/scala/tree/2.12.x/spec"><img src="public/images/github-logo@2x.png" alt="Edit at GitHub"></a><a href="01-lexical-syntax.html">1 Lexical Syntax</a><a href="02-identifiers-names-and-scopes.html">2 Identifiers, Names & Scopes</a><a href="03-types.html">3 Types</a><a href="04-basic-declarations-and-definitions.html">4 Basic Declarations & Definitions</a><a href="05-classes-and-objects.html">5 Classes & Objects</a><a href="06-expressions.html">6 Expressions</a><a href="07-implicits.html">7 Implicits</a><a href="08-pattern-matching.html">8 Pattern Matching</a><a href="09-top-level-definitions.html">9 Top-Level Definitions</a><a href="10-xml-expressions-and-patterns.html">10 XML</a><a href="11-annotations.html">11 Annotations</a><a href="12-the-scala-standard-library.html">12 Standard Library</a><a href="13-syntax-summary.html">13 Syntax Summary</a><a href="14-references.html">14 References</a><a href="15-changelog.html">15 Changelog</a></nav>
  </header>
  <aside class="left"><nav id="toc"></nav></aside>

  <main id="content">
<h1 id="pattern-matching">Pattern Matching</h1>

<h2 id="patterns">Patterns</h2>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf">  <a name="Pattern"></a>Pattern         ::=  <t>Pattern1</t> { ‘|’ <t>Pattern1</t> }
  <a name="Pattern1"></a>Pattern1        ::=  <t>boundvarid</t> ‘:’ <t>TypePat</t>
                    |  ‘_’ ‘:’ <t>TypePat</t>
                    |  <t>Pattern2</t>
  <a name="Pattern2"></a>Pattern2        ::=  <t>id</t> [‘@’ <t>Pattern3</t>]
                    |  <t>Pattern3</t>
  <a name="Pattern3"></a>Pattern3        ::=  <t>SimplePattern</t>
                    |  <t>SimplePattern</t> {<t>id</t> [<t>nl</t>] <t>SimplePattern</t>}
  <a name="SimplePattern"></a>SimplePattern   ::=  ‘_’
                    |  <t>varid</t>
                    |  <t>Literal</t>
                    |  <t>StableId</t>
                    |  <t>StableId</t> ‘(’ [<t>Patterns</t>] ‘)’
                    |  <t>StableId</t> ‘(’ [<t>Patterns</t> ‘,’] [<t>id</t> ‘@’] ‘_’ ‘*’ ‘)’
                    |  ‘(’ [<t>Patterns</t>] ‘)’
                    |  <t>XmlPattern</t>
  <a name="Patterns"></a>Patterns        ::=  <t>Pattern</t> {‘,’ <t>Patterns</t>}
</code></pre></div>
<p>A pattern is built from constants, constructors, variables and type
tests. Pattern matching tests whether a given value (or sequence of values)
has the shape defined by a pattern, and, if it does, binds the
variables in the pattern to the corresponding components of the value
(or sequence of values).  The same variable name may not be bound more
than once in a pattern.</p>

<h6 id="example">Example</h6>

<p>Some examples of patterns are:</p>

<ol>
<li> The pattern <code>ex: IOException</code> matches all instances of class
    <code>IOException</code>, binding variable <code>ex</code> to the instance.</li>
<li> The pattern <code>Some(x)</code> matches values of the form <code>Some($v$)</code>,
    binding <code>x</code> to the argument value $v$ of the <code>Some</code> constructor.</li>
<li> The pattern <code>(x, _)</code> matches pairs of values, binding <code>x</code> to
    the first component of the pair. The second component is matched
    with a wildcard pattern.</li>
<li> The pattern <code>x :: y :: xs</code> matches lists of length $\geq 2$,
    binding <code>x</code> to the list&#39;s first element, <code>y</code> to the list&#39;s
    second element, and <code>xs</code> to the remainder.</li>
<li> The pattern <code>1 | 2 | 3</code> matches the integers between 1 and 3.</li>
</ol>

<p>Pattern matching is always done in a context which supplies an
expected type of the pattern. We distinguish the following kinds of
patterns.</p>

<h3 id="variable-patterns">Variable Patterns</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf">  <a name="SimplePattern"></a>SimplePattern   ::=  ‘_’
                    |  <t>varid</t>
</code></pre></div>
<p>A <em>variable pattern</em> $x$ is a simple identifier which starts with a
lower case letter.  It matches any value, and binds the variable name
to that value.  The type of $x$ is the expected type of the pattern as
given from outside.  A special case is the wild-card pattern <code>_</code>
which is treated as if it was a fresh variable on each occurrence.</p>

<h3 id="typed-patterns">Typed Patterns</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf">  <a name="Pattern1"></a>Pattern1        ::=  <t>varid</t> ‘:’ <t>TypePat</t>
                    |  ‘_’ ‘:’ <t>TypePat</t>
</code></pre></div>
<p>A <em>typed pattern</em> $x: T$ consists of a pattern variable $x$ and a
type pattern $T$.  The type of $x$ is the type pattern $T$, where
each type variable and wildcard is replaced by a fresh, unknown type.
This pattern matches any value matched by the <a href="08-pattern-matching.html#type-patterns">type pattern</a>
$T$; it binds the variable name to
that value.</p>

<h3 id="pattern-binders">Pattern Binders</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf">  <a name="Pattern2"></a>Pattern2        ::=  <t>varid</t> ‘@’ <t>Pattern3</t>
</code></pre></div>
<p>A <em>pattern binder</em> <code>$x$@$p$</code> consists of a pattern variable $x$ and a
pattern $p$. The type of the variable $x$ is the static type $T$ of the pattern $p$.
This pattern matches any value $v$ matched by the pattern $p$,
provided the run-time type of $v$ is also an instance of $T$,
and it binds the variable name to that value.</p>

<h3 id="literal-patterns">Literal Patterns</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf">  <a name="SimplePattern"></a>SimplePattern   ::=  <t>Literal</t>
</code></pre></div>
<p>A <em>literal pattern</em> $L$ matches any value that is equal (in terms of
<code>==</code>) to the literal $L$. The type of $L$ must conform to the
expected type of the pattern.</p>

<h3 id="stable-identifier-patterns">Stable Identifier Patterns</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf">  <a name="SimplePattern"></a>SimplePattern   ::=  <t>StableId</t>
</code></pre></div>
<p>A <em>stable identifier pattern</em> is a <a href="03-types.html#paths">stable identifier</a> $r$.
The type of $r$ must conform to the expected
type of the pattern. The pattern matches any value $v$ such that
<code>$r$ == $v$</code> (see <a href="12-the-scala-standard-library.html#root-classes">here</a>).</p>

<p>To resolve the syntactic overlap with a variable pattern, a
stable identifier pattern may not be a simple name starting with a lower-case
letter. However, it is possible to enclose such a variable name in
backquotes; then it is treated as a stable identifier pattern.</p>

<h6 id="example">Example</h6>

<p>Consider the following function definition:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">def f(x: Int, y: Int) = x match {
  case y =&gt; ...
}
</code></pre></div>
<p>Here, <code>y</code> is a variable pattern, which matches any value.
If we wanted to turn the pattern into a stable identifier pattern, this
can be achieved as follows:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">def f(x: Int, y: Int) = x match {
  case `y` =&gt; ...
}
</code></pre></div>
<p>Now, the pattern matches the <code>y</code> parameter of the enclosing function <code>f</code>.
That is, the match succeeds only if the <code>x</code> argument and the <code>y</code>
argument of <code>f</code> are equal.</p>

<h3 id="constructor-patterns">Constructor Patterns</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf"><a name="SimplePattern"></a>SimplePattern   ::=  <t>StableId</t> ‘(’ [<t>Patterns</t>] ‘)’
</code></pre></div>
<p>A <em>constructor pattern</em> is of the form $c(p_1 , \ldots , p_n)$ where $n
\geq 0$. It consists of a stable identifier $c$, followed by element
patterns $p_1 , \ldots , p_n$. The constructor $c$ is a simple or
qualified name which denotes a <a href="05-classes-and-objects.html#case-classes">case class</a>.
If the case class is monomorphic, then it
must conform to the expected type of the pattern, and the formal
parameter types of $x$&#39;s <a href="05-classes-and-objects.html#class-definitions">primary constructor</a>
are taken as the expected types of the element patterns $p_1, \ldots ,
p_n$.  If the case class is polymorphic, then its type parameters are
instantiated so that the instantiation of $c$ conforms to the expected
type of the pattern. The instantiated formal parameter types of $c$&#39;s
primary constructor are then taken as the expected types of the
component patterns $p_1, \ldots , p_n$.  The pattern matches all
objects created from constructor invocations $c(v_1 , \ldots , v_n)$
where each element pattern $p_i$ matches the corresponding value
$v_i$.</p>

<p>A special case arises when $c$&#39;s formal parameter types end in a
repeated parameter. This is further discussed <a href="08-pattern-matching.html#pattern-sequences">here</a>.</p>

<h3 id="tuple-patterns">Tuple Patterns</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf">  <a name="SimplePattern"></a>SimplePattern   ::=  ‘(’ [<t>Patterns</t>] ‘)’
</code></pre></div>
<p>A <em>tuple pattern</em> <code>($p_1 , \ldots , p_n$)</code> is an alias
for the constructor pattern <code>scala.Tuple$n$($p_1 , \ldots , p_n$)</code>,
where $n \geq 2$. The empty tuple
<code>()</code> is the unique value of type <code>scala.Unit</code>.</p>

<h3 id="extractor-patterns">Extractor Patterns</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf">  <a name="SimplePattern"></a>SimplePattern   ::=  <t>StableId</t> ‘(’ [<t>Patterns</t>] ‘)’
</code></pre></div>
<p>An <em>extractor pattern</em> $x(p_1 , \ldots , p_n)$ where $n \geq 0$ is of
the same syntactic form as a constructor pattern. However, instead of
a case class, the stable identifier $x$ denotes an object which has a
member method named <code>unapply</code> or <code>unapplySeq</code> that matches
the pattern.</p>

<p>An <code>unapply</code> method in an object $x$ <em>matches</em> the pattern
$x(p_1 , \ldots , p_n)$ if it takes exactly one argument and one of
the following applies:</p>

<ul>
<li>$n=0$ and <code>unapply</code>&#39;s result type is <code>Boolean</code>. In this case
the extractor pattern matches all values $v$ for which
<code>$x$.unapply($v$)</code> yields <code>true</code>.</li>
<li>$n=1$ and <code>unapply</code>&#39;s result type is <code>Option[$T$]</code>, for some
type $T$.  In this case, the (only) argument pattern $p_1$ is typed in
turn with expected type $T$.  The extractor pattern matches then all
values $v$ for which <code>$x$.unapply($v$)</code> yields a value of form
<code>Some($v_1$)</code>, and $p_1$ matches $v_1$.</li>
<li>$n&gt;1$ and <code>unapply</code>&#39;s result type is
<code>Option[($T_1 , \ldots , T_n$)]</code>, for some
types $T_1 , \ldots , T_n$.  In this case, the argument patterns $p_1
, \ldots , p_n$ are typed in turn with expected types $T_1 , \ldots ,
T_n$.  The extractor pattern matches then all values $v$ for which
<code>$x$.unapply($v$)</code> yields a value of form
<code>Some(($v_1 , \ldots , v_n$))</code>, and each pattern
$p_i$ matches the corresponding value $v_i$.</li>
</ul>

<p>An <code>unapplySeq</code> method in an object $x$ matches the pattern
$x(q_1 , \ldots , q_m, p_1 , \ldots , p_n)$ if it takes exactly one argument
and its result type is of the form <code>Option[($T_1 , \ldots , T_m$, Seq[S])]</code> (if <code>m = 0</code>, the type <code>Option[Seq[S]]</code> is also accepted).
This case is further discussed <a href="08-pattern-matching.html#pattern-sequences">below</a>.</p>

<h6 id="example">Example</h6>

<p>The <code>Predef</code> object contains a definition of an
extractor object <code>Pair</code>:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">object Pair {
  def apply[A, B](x: A, y: B) = Tuple2(x, y)
  def unapply[A, B](x: Tuple2[A, B]): Option[Tuple2[A, B]] = Some(x)
}
</code></pre></div>
<p>This means that the name <code>Pair</code> can be used in place of <code>Tuple2</code> for tuple
formation as well as for deconstruction of tuples in patterns.
Hence, the following is possible:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">val x = (1, 2)
val y = x match {
  case Pair(i, s) =&gt; Pair(s + i, i * i)
}
</code></pre></div>
<h3 id="pattern-sequences">Pattern Sequences</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf"><a name="SimplePattern"></a>SimplePattern ::= <t>StableId</t> ‘(’ [<t>Patterns</t> ‘,’] [<t>varid</t> ‘@’] ‘_’ ‘*’ ‘)’
</code></pre></div>
<p>A <em>pattern sequence</em> $p_1 , \ldots , p_n$ appears in two contexts.
First, in a constructor pattern $c(q_1 , \ldots , q_m, p_1 , \ldots , p_n)$, where $c$ is a case class which has $m+1$ primary constructor parameters,  ending in a <a href="04-basic-declarations-and-definitions.html#repeated-parameters">repeated parameter</a> of type <code>S*</code>.
Second, in an extractor pattern $x(q_1 , \ldots , q_m, p_1 , \ldots , p_n)$ if the extractor object $x$ does not have an <code>unapply</code> method,
but it does define an <code>unapplySeq</code> method with a result type conforming to <code>Option[(T_1, ... , T_m, Seq[S])]</code> (if <code>m = 0</code>, the type <code>Option[Seq[S]]</code> is also accepted). The expected type for the patterns $p_i$ is $S$.</p>

<p>The last pattern in a pattern sequence may be a <em>sequence wildcard</em> <code>_*</code>.
Each element pattern $p_i$ is type-checked with
$S$ as expected type, unless it is a sequence wildcard. If a final
sequence wildcard is present, the pattern matches all values $v$ that
are sequences which start with elements matching patterns
$p_1 , \ldots , p_{n-1}$.  If no final sequence wildcard is given, the
pattern matches all values $v$ that are sequences of
length $n$ which consist of elements matching patterns $p_1 , \ldots ,
p_n$.</p>

<h3 id="infix-operation-patterns">Infix Operation Patterns</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf">  <a name="Pattern3"></a>Pattern3  ::=  <t>SimplePattern</t> {<t>id</t> [<t>nl</t>] <t>SimplePattern</t>}
</code></pre></div>
<p>An <em>infix operation pattern</em> $p;\mathit{op};q$ is a shorthand for the
constructor or extractor pattern $\mathit{op}(p, q)$.  The precedence and
associativity of operators in patterns is the same as in
<a href="06-expressions.html#prefix,-infix,-and-postfix-operations">expressions</a>.</p>

<p>An infix operation pattern $p;\mathit{op};(q_1 , \ldots , q_n)$ is a
shorthand for the constructor or extractor pattern $\mathit{op}(p, q_1
, \ldots , q_n)$.</p>

<h3 id="pattern-alternatives">Pattern Alternatives</h3>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf">  <a name="Pattern"></a>Pattern   ::=  <t>Pattern1</t> { ‘|’ <t>Pattern1</t> }
</code></pre></div>
<p>A <em>pattern alternative</em> <code>$p_1$ | $\ldots$ | $p_n$</code>
consists of a number of alternative patterns $p_i$. All alternative
patterns are type checked with the expected type of the pattern. They
may not bind variables other than wildcards. The alternative pattern
matches a value $v$ if at least one its alternatives matches $v$.</p>

<h3 id="xml-patterns">XML Patterns</h3>

<p>XML patterns are treated <a href="10-xml-expressions-and-patterns.html#xml-patterns">here</a>.</p>

<h3 id="regular-expression-patterns">Regular Expression Patterns</h3>

<p>Regular expression patterns have been discontinued in Scala from version 2.0.</p>

<p>Later version of Scala provide a much simplified version of regular
expression patterns that cover most scenarios of non-text sequence
processing.  A <em>sequence pattern</em> is a pattern that stands in a
position where either (1) a pattern of a type <code>T</code> which is
conforming to
<code>Seq[A]</code> for some <code>A</code> is expected, or (2) a case
class constructor that has an iterated formal parameter
<code>A*</code>.  A wildcard star pattern <code>_*</code> in the
rightmost position stands for arbitrary long sequences. It can be
bound to variables using <code>@</code>, as usual, in which case the variable will have the
type <code>Seq[A]</code>.</p>

<h3 id="irrefutable-patterns">Irrefutable Patterns</h3>

<p>A pattern $p$ is <em>irrefutable</em> for a type $T$, if one of the following applies:</p>

<ol>
<li> $p$ is a variable pattern,</li>
<li> $p$ is a typed pattern $x: T&#39;$, and $T &lt;: T&#39;$,</li>
<li> $p$ is a constructor pattern $c(p_1 , \ldots , p_n)$, the type $T$
is an instance of class $c$, the <a href="05-classes-and-objects.html#class-definitions">primary constructor</a>
of type $T$ has argument types $T_1 , \ldots , T_n$, and each $p_i$ is
irrefutable for $T_i$.</li>
</ol>

<h2 id="type-patterns">Type Patterns</h2>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf">  <a name="TypePat"></a>TypePat           ::=  <t>Type</t>
</code></pre></div>
<p>Type patterns consist of types, type variables, and wildcards.
A type pattern $T$ is of one of the following  forms:</p>

<ul>
<li>A reference to a class $C$, $p.C$, or <code>$T$#$C$</code>.  This
type pattern matches any non-null instance of the given class.
Note that the prefix of the class, if it exists, is relevant for determining
class instances. For instance, the pattern $p.C$ matches only
instances of classes $C$ which were created with the path $p$ as
prefix. This also applies to prefixes which are not given syntactically.
For example, if $C$ refers to a class defined in the nearest enclosing
class and is thus equivalent to $this.C$, it is considered to have a prefix.</li>
</ul>

<p>The bottom types <code>scala.Nothing</code> and <code>scala.Null</code> cannot
  be used as type patterns, because they would match nothing in any case.</p>

<ul>
<li>A singleton type <code>$p$.type</code>. This type pattern matches only the value
denoted by the path $p$ (that is, a pattern match involved a
comparison of the matched value with $p$ using method <code>eq</code> in class
<code>AnyRef</code>).</li>
<li><p>A compound type pattern <code>$T_1$ with $\ldots$ with $T_n$</code> where each $T_i$ is a
type pattern. This type pattern matches all values that are matched by each of
the type patterns $T_i$.</p></li>
<li><p>A parameterized type pattern $T[a_1 , \ldots , a_n]$, where the $a_i$
are type variable patterns or wildcards <code>_</code>.
This type pattern matches all values which match $T$ for
some arbitrary instantiation of the type variables and wildcards. The
bounds or alias type of these type variable are determined as
described <a href="08-pattern-matching.html#type-parameter-inference-in-patterns">here</a>.</p></li>
<li><p>A parameterized type pattern <code>scala.Array$[T_1]$</code>, where
$T_1$ is a type pattern. This type pattern matches any non-null instance
of type <code>scala.Array$[U_1]$</code>, where $U_1$ is a type matched by $T_1$.</p></li>
</ul>

<p>Types which are not of one of the forms described above are also
accepted as type patterns. However, such type patterns will be translated to their
<a href="03-types.html#type-erasure">erasure</a>.  The Scala
compiler will issue an &quot;unchecked&quot; warning for these patterns to
flag the possible loss of type-safety.</p>

<p>A <em>type variable pattern</em> is a simple identifier which starts with
a lower case letter.</p>

<h2 id="type-parameter-inference-in-patterns">Type Parameter Inference in Patterns</h2>

<p>Type parameter inference is the process of finding bounds for the
bound type variables in a typed pattern or constructor
pattern. Inference takes into account the expected type of the
pattern.</p>

<h3 id="type-parameter-inference-for-typed-patterns">Type parameter inference for typed patterns</h3>

<p>Assume a typed pattern $p: T&#39;$. Let $T$ result from $T&#39;$ where all wildcards in
$T&#39;$ are renamed to fresh variable names. Let $a_1 , \ldots , a_n$ be
the type variables in $T$. These type variables are considered bound
in the pattern. Let the expected type of the pattern be $\mathit{pt}$.</p>

<p>Type parameter inference constructs first a set of subtype constraints over
the type variables $a_i$. The initial constraints set $\mathcal{C}_0$ reflects
just the bounds of these type variables. That is, assuming $T$ has
bound type variables $a_1 , \ldots , a_n$ which correspond to class
type parameters $a_1&#39; , \ldots , a_n&#39;$ with lower bounds $L_1, \ldots , L_n$
and upper bounds $U_1 , \ldots , U_n$, $\mathcal{C}_0$ contains the constraints</p>

<p>$$
\begin{cases}
a_i &amp;&lt;: \sigma U_i &amp; \quad (i = 1, \ldots , n) \\
\sigma L_i &amp;&lt;: a_i &amp; \quad (i = 1, \ldots , n)
\end{cases}
$$</p>

<p>where $\sigma$ is the substitution $[a_1&#39; := a_1 , \ldots , a_n&#39; :=a_n]$.</p>

<p>The set $\mathcal{C}_0$ is then augmented by further subtype constraints. There are two
cases.</p>

<h6 id="case-1">Case 1</h6>

<p>If there exists a substitution $\sigma$ over the type variables $a_i , \ldots , a_n$ such that $\sigma T$ conforms to $\mathit{pt}$, one determines the weakest subtype constraints
$\mathcal{C}_1$ over the type variables $a_1, \ldots , a_n$ such that $\mathcal{C}_0 \wedge \mathcal{C}_1$ implies that $T$ conforms to $\mathit{pt}$.</p>

<h6 id="case-2">Case 2</h6>

<p>Otherwise, if $T$ can not be made to conform to $\mathit{pt}$ by
instantiating its type variables, one determines all type variables in
$\mathit{pt}$ which are defined as type parameters of a method enclosing
the pattern. Let the set of such type parameters be $b_1 , \ldots ,
b_m$. Let $\mathcal{C}_0&#39;$ be the subtype constraints reflecting the bounds of the
type variables $b_i$.  If $T$ denotes an instance type of a final
class, let $\mathcal{C}_2$ be the weakest set of subtype constraints over the type
variables $a_1 , \ldots , a_n$ and $b_1 , \ldots , b_m$ such that
$\mathcal{C}_0 \wedge \mathcal{C}_0&#39; \wedge \mathcal{C}_2$ implies that $T$ conforms to
$\mathit{pt}$.  If $T$ does not denote an instance type of a final class,
let $\mathcal{C}_2$ be the weakest set of subtype constraints over the type variables
$a_1 , \ldots , a_n$ and $b_1 , \ldots , b_m$ such that $\mathcal{C}_0 \wedge
\mathcal{C}_0&#39; \wedge \mathcal{C}_2$ implies that it is possible to construct a type
$T&#39;$ which conforms to both $T$ and $\mathit{pt}$. It is a static error if
there is no satisfiable set of constraints $\mathcal{C}_2$ with this property.</p>

<p>The final step consists in choosing type bounds for the type
variables which imply the established constraint system. The process
is different for the two cases above.</p>

<h6 id="case-1">Case 1</h6>

<p>We take $a_i &gt;: L_i &lt;: U_i$ where each $L_i$ is minimal and each $U_i$ is maximal wrt $&lt;:$ such that $a_i &gt;: L_i &lt;: U_i$ for $i = 1, \ldots, n$ implies $\mathcal{C}_0 \wedge \mathcal{C}_1$.</p>

<h6 id="case-2">Case 2</h6>

<p>We take $a_i &gt;: L_i &lt;: U_i$ and $b_i &gt;: L_i&#39; &lt;: U_i&#39; $ where each $L_i$
and $L_j&#39;$ is minimal and each $U_i$ and $U_j&#39;$ is maximal such that
$a_i &gt;: L_i &lt;: U_i$ for $i = 1 , \ldots , n$ and
$b_j &gt;: L_j&#39; &lt;: U_j&#39;$ for $j = 1 , \ldots , m$
implies $\mathcal{C}_0 \wedge \mathcal{C}_0&#39; \wedge \mathcal{C}_2$.</p>

<p>In both cases, local type inference is permitted to limit the
complexity of inferred bounds. Minimality and maximality of types have
to be understood relative to the set of types of acceptable
complexity.</p>

<h3 id="type-parameter-inference-for-constructor-patterns">Type parameter inference for constructor patterns</h3>

<p>Assume a constructor pattern $C(p_1 , \ldots , p_n)$ where class $C$
has type parameters $a_1 , \ldots , a_n$.  These type parameters
are inferred in the same way as for the typed pattern
<code>(_: $C[a_1 , \ldots , a_n]$)</code>.</p>

<h6 id="example">Example</h6>

<p>Consider the program fragment:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">val x: Any
x match {
  case y: List[a] =&gt; ...
}
</code></pre></div>
<p>Here, the type pattern <code>List[a]</code> is matched against the
expected type <code>Any</code>. The pattern binds the type variable
<code>a</code>.  Since <code>List[a]</code> conforms to <code>Any</code>
for every type argument, there are no constraints on <code>a</code>.
Hence, <code>a</code> is introduced as an abstract type with no
bounds. The scope of <code>a</code> is right-hand side of its case clause.</p>

<p>On the other hand, if <code>x</code> is declared as</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">val x: List[List[String]],
</code></pre></div>
<p>this generates the constraint
<code>List[a] &lt;: List[List[String]]</code>, which simplifies to
<code>a &lt;: List[String]</code>, because <code>List</code> is covariant. Hence,
<code>a</code> is introduced with upper bound
<code>List[String]</code>.</p>

<h6 id="example">Example</h6>

<p>Consider the program fragment:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">val x: Any
x match {
  case y: List[String] =&gt; ...
}
</code></pre></div>
<p>Scala does not maintain information about type arguments at run-time,
so there is no way to check that <code>x</code> is a list of strings.
Instead, the Scala compiler will <a href="03-types.html#type-erasure">erase</a> the
pattern to <code>List[_]</code>; that is, it will only test whether the
top-level runtime-class of the value <code>x</code> conforms to
<code>List</code>, and the pattern match will succeed if it does.  This
might lead to a class cast exception later on, in the case where the
list <code>x</code> contains elements other than strings.  The Scala
compiler will flag this potential loss of type-safety with an
&quot;unchecked&quot; warning message.</p>

<h6 id="example">Example</h6>

<p>Consider the program fragment</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">class Term[A]
class Number(val n: Int) extends Term[Int]
def f[B](t: Term[B]): B = t match {
  case y: Number =&gt; y.n
}
</code></pre></div>
<p>The expected type of the pattern <code>y: Number</code> is
<code>Term[B]</code>.  The type <code>Number</code> does not conform to
<code>Term[B]</code>; hence Case 2 of the rules above
applies. This means that <code>B</code> is treated as another type
variable for which subtype constraints are inferred. In our case the
applicable constraint is <code>Number &lt;: Term[B]</code>, which
entails <code>B = Int</code>.  Hence, <code>B</code> is treated in
the case clause as an abstract type with lower and upper bound
<code>Int</code>. Therefore, the right hand side of the case clause,
<code>y.n</code>, of type <code>Int</code>, is found to conform to the
function&#39;s declared result type, <code>Number</code>.</p>

<h2 id="pattern-matching-expressions">Pattern Matching Expressions</h2>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf">  <a name="Expr"></a>Expr            ::=  <t>PostfixExpr</t> ‘match’ ‘{’ <t>CaseClauses</t> ‘}’
  <a name="CaseClauses"></a>CaseClauses     ::=  <t>CaseClause</t> {<t>CaseClause</t>}
  <a name="CaseClause"></a>CaseClause      ::=  ‘case’ <t>Pattern</t> [<t>Guard</t>] ‘=&gt;’ <t>Block</t>
</code></pre></div>
<p>A <em>pattern matching expression</em></p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">e match { case $p_1$ =&gt; $b_1$ $\ldots$ case $p_n$ =&gt; $b_n$ }
</code></pre></div>
<p>consists of a selector expression $e$ and a number $n &gt; 0$ of
cases. Each case consists of a (possibly guarded) pattern $p_i$ and a
block $b_i$. Each $p_i$ might be complemented by a guard
<code>if $e$</code> where $e$ is a boolean expression.
The scope of the pattern
variables in $p_i$ comprises the pattern&#39;s guard and the corresponding block $b_i$.</p>

<p>Let $T$ be the type of the selector expression $e$ and let $a_1
, \ldots , a_m$ be the type parameters of all methods enclosing
the pattern matching expression.  For every $a_i$, let $L_i$ be its
lower bound and $U_i$ be its higher bound.  Every pattern $p \in {p_1, , \ldots , p_n}$
can be typed in two ways. First, it is attempted
to type $p$ with $T$ as its expected type. If this fails, $p$ is
instead typed with a modified expected type $T&#39;$ which results from
$T$ by replacing every occurrence of a type parameter $a_i$ by
\mbox{\sl undefined}.  If this second step fails also, a compile-time
error results. If the second step succeeds, let $T_p$ be the type of
pattern $p$ seen as an expression. One then determines minimal bounds
$L_11 , \ldots , L_m&#39;$ and maximal bounds $U_1&#39; , \ldots , U_m&#39;$ such
that for all $i$, $L_i &lt;: L_i&#39;$ and $U_i&#39; &lt;: U_i$ and the following
constraint system is satisfied:</p>

<p>$$L_1 &lt;: a_1 &lt;: U_1\;\wedge\;\ldots\;\wedge\;L_m &lt;: a_m &lt;: U_m \ \Rightarrow\ T_p &lt;: T$$</p>

<p>If no such bounds can be found, a compile time error results.  If such
bounds are found, the pattern matching clause starting with $p$ is
then typed under the assumption that each $a_i$ has lower bound $L_i&#39;$
instead of $L_i$ and has upper bound $U_i&#39;$ instead of $U_i$.</p>

<p>The expected type of every block $b_i$ is the expected type of the
whole pattern matching expression.  The type of the pattern matching
expression is then the <a href="03-types.html#weak-conformance">weak least upper bound</a>
of the types of all blocks
$b_i$.</p>

<p>When applying a pattern matching expression to a selector value,
patterns are tried in sequence until one is found which matches the
<a href="08-pattern-matching.html#patterns">selector value</a>. Say this case is <code>case $p_i \Rightarrow b_i$</code>.
The result of the whole expression is the result of evaluating $b_i$,
where all pattern variables of $p_i$ are bound to
the corresponding parts of the selector value.  If no matching pattern
is found, a <code>scala.MatchError</code> exception is thrown.</p>

<p>The pattern in a case may also be followed by a guard suffix
<code>if e</code> with a boolean expression $e$.  The guard expression is
evaluated if the preceding pattern in the case matches. If the guard
expression evaluates to <code>true</code>, the pattern match succeeds as
normal. If the guard expression evaluates to <code>false</code>, the pattern
in the case is considered not to match and the search for a matching
pattern continues.</p>

<p>In the interest of efficiency the evaluation of a pattern matching
expression may try patterns in some other order than textual
sequence. This might affect evaluation through
side effects in guards. However, it is guaranteed that a guard
expression is evaluated only if the pattern it guards matches.</p>

<p>If the selector of a pattern match is an instance of a
<a href="05-classes-and-objects.html#modifiers"><code>sealed</code> class</a>,
the compilation of pattern matching can emit warnings which diagnose
that a given set of patterns is not exhaustive, i.e. that there is a
possibility of a <code>MatchError</code> being raised at run-time.</p>

<h6 id="example">Example</h6>

<p>Consider the following definitions of arithmetic terms:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">abstract class Term[T]
case class Lit(x: Int) extends Term[Int]
case class Succ(t: Term[Int]) extends Term[Int]
case class IsZero(t: Term[Int]) extends Term[Boolean]
case class If[T](c: Term[Boolean],
                 t1: Term[T],
                 t2: Term[T]) extends Term[T]
</code></pre></div>
<p>There are terms to represent numeric literals, incrementation, a zero
test, and a conditional. Every term carries as a type parameter the
type of the expression it represents (either <code>Int</code> or <code>Boolean</code>).</p>

<p>A type-safe evaluator for such terms can be written as follows.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">def eval[T](t: Term[T]): T = t match {
  case Lit(n)        =&gt; n
  case Succ(u)       =&gt; eval(u) + 1
  case IsZero(u)     =&gt; eval(u) == 0
  case If(c, u1, u2) =&gt; eval(if (eval(c)) u1 else u2)
}
</code></pre></div>
<p>Note that the evaluator makes crucial use of the fact that type
parameters of enclosing methods can acquire new bounds through pattern
matching.</p>

<p>For instance, the type of the pattern in the second case,
<code>Succ(u)</code>, is <code>Int</code>. It conforms to the selector type
<code>T</code> only if we assume an upper and lower bound of <code>Int</code> for <code>T</code>.
Under the assumption <code>Int &lt;: T &lt;: Int</code> we can also
verify that the type right hand side of the second case, <code>Int</code>
conforms to its expected type, <code>T</code>.</p>

<h2 id="pattern-matching-anonymous-functions">Pattern Matching Anonymous Functions</h2>
<div class="highlight"><pre><code class="language-ebnf" data-lang="ebnf">  <a name="BlockExpr"></a>BlockExpr ::= ‘{’ <t>CaseClauses</t> ‘}’
</code></pre></div>
<p>An anonymous function can be defined by a sequence of cases</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">{ case $p_1$ =&gt; $b_1$ $\ldots$ case $p_n$ =&gt; $b_n$ }
</code></pre></div>
<p>which appear as an expression without a prior <code>match</code>.  The
expected type of such an expression must in part be defined. It must
be either <code>scala.Function$k$[$S_1 , \ldots , S_k$, $R$]</code> for some $k &gt; 0$,
or <code>scala.PartialFunction[$S_1$, $R$]</code>, where the
argument type(s) $S_1 , \ldots , S_k$ must be fully determined, but the result type
$R$ may be undetermined.</p>

<p>If the expected type is <a href="06-expressions.html#sam-conversion">SAM-convertible</a>
to <code>scala.Function$k$[$S_1 , \ldots , S_k$, $R$]</code>,
the expression is taken to be equivalent to the anonymous function:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">($x_1: S_1 , \ldots , x_k: S_k$) =&gt; ($x_1 , \ldots , x_k$) match {
  case $p_1$ =&gt; $b_1$ $\ldots$ case $p_n$ =&gt; $b_n$
}
</code></pre></div>
<p>Here, each $x_i$ is a fresh name.
As was shown <a href="06-expressions.html#anonymous-functions">here</a>, this anonymous function is in turn
equivalent to the following instance creation expression, where
 $T$ is the weak least upper bound of the types of all $b_i$.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">new scala.Function$k$[$S_1 , \ldots , S_k$, $T$] {
  def apply($x_1: S_1 , \ldots , x_k: S_k$): $T$ = ($x_1 , \ldots , x_k$) match {
    case $p_1$ =&gt; $b_1$ $\ldots$ case $p_n$ =&gt; $b_n$
  }
}
</code></pre></div>
<p>If the expected type is <code>scala.PartialFunction[$S$, $R$]</code>,
the expression is taken to be equivalent to the following instance creation expression:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">new scala.PartialFunction[$S$, $T$] {
  def apply($x$: $S$): $T$ = x match {
    case $p_1$ =&gt; $b_1$ $\ldots$ case $p_n$ =&gt; $b_n$
  }
  def isDefinedAt($x$: $S$): Boolean = {
    case $p_1$ =&gt; true $\ldots$ case $p_n$ =&gt; true
    case _ =&gt; false
  }
}
</code></pre></div>
<p>Here, $x$ is a fresh name and $T$ is the weak least upper bound of the
types of all $b_i$. The final default case in the <code>isDefinedAt</code>
method is omitted if one of the patterns $p_1 , \ldots , p_n$ is
already a variable or wildcard pattern.</p>

<h6 id="example">Example</h6>

<p>Here is a method which uses a fold-left operation
<code>/:</code> to compute the scalar product of
two vectors:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">def scalarProduct(xs: Array[Double], ys: Array[Double]) =
  (0.0 /: (xs zip ys)) {
    case (a, (b, c)) =&gt; a + b * c
  }
</code></pre></div>
<p>The case clauses in this code are equivalent to the following
anonymous function:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">(x, y) =&gt; (x, y) match {
  case (a, (b, c)) =&gt; a + b * c
}
</code></pre></div>
  </main>

  <script src="public/scripts/toc.js"></script>
  <script src="public/scripts/highlight.pack.js"></script>
  <script src="public/scripts/main.js"></script>
</body>
</html>
